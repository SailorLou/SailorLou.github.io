---
layout:     post
title:      "C++常用基础知识汇总"
subtitle:   "基础知识总结"
date:       2019-05-25 16:00:00
author:     "Sailor"
categories:  C++
mathjax: true
tags:  C++
---

##  C++ 常用基础知识汇总
本偏文章主要是对之前工作和学习中笔记的一个总结和整理并放在播客中利于自己的复习和查看.
<!-- more -->

### inline 函数
- 能用inline而避免用宏
- 和宏区别:宏是预处理阶段，inline是告诉或建议编译器是内敛函数
- inline一定和定义放在一起，只和声明放在一起没有效果，
- inline函数一定是小型函数，杜绝使用while等复杂语句
- inline 函数定义和申明一定在一个文件中，或者声明在一个头文件，定义放在其他文件中，但在头文件中必须include这个文件。

### 模板注意事项
- 模板函数或成员函数的申明和定义不能像常规头文件和cpp文件那样分开，必须放在一个文件中，或是定义放在另一个文件中，声明放在头文件中，但头文件中必须inlcude该文件（定义模板函数的）


### 四种类型转换
- static_cast，编译时期的静态类型检测
    - void* 与其他类型的转换
    - 也可基础类型之间的转换
    - 函数指针的转换，比如QT中的重载槽函数static_cast<void (QButtonGroup::*)(int, bool)>(&QButtonGroup::buttonToggled)
- dynamic_cast，运行时检测，基类到派生类的转换，是RTTI的一员
- const_cast 
- reinterpret_cast，可用于在指针和整型之间，在不相关的指针类型之间，在指向成员的指针类型之间，和在指向函数的指针类型之间转换类型。该转换-运算符不能用来删除，也不能用来在指向同一类分层结构中不同类的指针之间进行转换。运算符是用来处理无关类型之间的转换；它会产生一个新的值，这个值会有与原始参数有完全相同的比特位，也就是相同的二进制流。它不会判断转换的合法性，

### RTTI（Runtime Type Information）
- 运行时类型识别
- 为了能够在运行时正确判断一个对象确切的类型，加入了RTTI和type_info
- 每一个类中都有一个type_info对象- <深度探索C++对象模型>
- dynamic_cast
- typied运算符指出对象的类型的值，返回一个type_info的引用
- type_info 重载函数 operator==() 和 operator!=(),从而实现类型比较.tye_info的成员函数name()返回类型的名字.判断两个子类是不是属于一个类型可以用：typeid(subclass1) == typeid(subclass2)

###  volatile 
- 三个特性：易变性；不可优化性；顺序性
- 顺序性”，能够保证Volatile变量间的顺序性，编译器不会进行乱序优化
- 多线程程序设计时，要小心使用volatile

### 类中的虚函数
- 虚函数表 是在编译器构建，并且虚函数表属于类，内存属于全局内存区中，每一个类对象共享这个虚函数表.
- 类对象的虚函数指针vptr是在运行阶段确定
- 虚构造函数防止内存泄漏

### 宏定义
- 宏定义中的#是把跟在后面的参数转成一个字符串，如#define  strcpy__(dst, src)      strcpy(dst, #src)
- ##是连接符号，把参数连接在一起，如#define Son(son) my##son
- #@:将值序列变为一个字符，如#define ToChar(c) #@c  相当于把c变成字符'c'

### 函数重载
- 定义：同一作用域内，具有相同函数名，不同参数列表的函数，这组函数被称为重载函数。
- 内层作用域的函数会隐藏外层的同名函数，同样的派生类的成员函数会隐藏基类的同名函数。
- 不能靠返回值类型的不同来区分重载函数.
- 重载，重写（覆盖）和赢藏的区别:
    - 重载：是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。
    - 隐藏：是指派生类的函数屏蔽了与其同名的基类函数，注意只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。
    - 重写(覆盖)：是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。
- 重载和重写的区别：
    - 范围区别：重写和被重写的函数在不同的类中，重载和被重载的函数在同一类中。
    - 参数区别：重写与被重写的函数参数列表一定相同，重载和被重载的函数参数列表一定不同。
    - virtual的区别：重写的基类必须要有virtual修饰，重载函数和被重载函数可以被virtual修饰，也可以没有。
- 隐藏和重写，重载的区别：
    - 与重载范围不同：隐藏函数和被隐藏函数在不同类中。
    - 参数的区别：隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定同；当参数不同时，无论基类中的函数是否被virtual修饰，基类函数都是被隐藏，而不是被重写。
